/* server.js - Express server for NoteWorthy*/
'use strict';

const adminID = '5e7e5bd54b8b10001761dcf4'

// Express
const express = require('express')
const app = express();
const bodyParser = require('body-parser')
app.use(bodyParser.json());

//CORS fix
const cors = require('cors');
app.use(cors());

// express-session for managing user sessions
const session = require('express-session')
app.use(bodyParser.urlencoded({ extended: true }));

// Mongo and Mongoose
const { ObjectID } = require('mongodb')
const { mongoose } = require('./db/mongoose');
const { Album } = require('./models/album')
const { User } = require('./models/user')
const { Review } = require('./models/review')
const { PendingAlbumSubmission } = require('./models/pendingAlbumSubmission')
const { Image } = require("./models/image");
const { Collection } = require("./models/collections");
const { ViewableUser } = require("./models/viewableuser");
const { savedAlbum } = require ('./models/savedAlbum.js')


// multipart middleware: allows you to access uploaded file from req.file
const multipart = require('connect-multiparty');
const multipartMiddleware = multipart();


// cloudinary: configure using credentials found on your Cloudinary Dashboard
const cloudinary = require('cloudinary');

cloudinary.config({
  cloud_name: 'keatingh',
  api_key: '583158277248312',
  api_secret: 'qEaGYgsVpsnQ2VY_9DbhYiSirv4'
});


app.use(express.static(__dirname + '/public'));

/*** Session handling **************************************/
// Create a session cookie
// Taken from lecture slides
app.use(session({
  secret: 'oursecret',
  resave: false,
  saveUninitialized: false,
  cookie: {
    httpOnly: true
  }
}));

// // Our own express middleware to check for
// // an active user on the session cookie (indicating a logged in user.)
//taken for the course notes
const sessionChecker = (req, res, next) => {
  if (req.session.user) {
    res.redirect('/dashboard'); // redirect to dashboard if logged in.
  } else {
    next(); // next() moves on to the route.
  }
};

// // Our own express middleware to check for
// // an active user on the session cookie (indicating a logged in user.)
//taken for the course notes
const isSessionDead = (req, res, next) => {
  if (!req.session.user) {
    res.redirect('/index'); // redirect to index if the session has died
  } else {
    next(); // next() moves on to the route.
  }
};

/// DIRECT TO WEB PAGES
app.get('/',(req, res) => {
  res.redirect('/index')
})

app.get('/index',sessionChecker,(req, res) => {
  res.sendFile('./public/index.html', {root: __dirname })
})

app.get('/newuser', (req, res) => {
  res.sendFile('/public/newuser.html', {root: __dirname })
})

app.get('/dashboard',isSessionDead, (req, res) => {
  req.session.userviewable = null
  req.session.album = null
  req.session.collectionid = null
  res.sendFile('./public/dashboard.html', {root: __dirname })
})

app.get('/friendlist',isSessionDead, (req, res) => {
  res.sendFile('./public/user_friend_list.html', {root: __dirname })
})

app.get('/viewable_friendlist',isSessionDead, (req, res) => {
  res.sendFile('./public/userviewable_friend_list.html', {root: __dirname })
})

app.get('/album',isSessionDead, (req, res) => {
  if(!  req.session.album )
  {
    res.redirect('/dashboard')
  }
  else {
  res.sendFile('./public/album.html', {root: __dirname })
}
})

app.get('/searchResult', isSessionDead,(req, res) => {
  res.sendFile('./public/search_results.html', {root: __dirname })
})

app.get('/submitalbum', isSessionDead,(req, res) => {
  res.sendFile('./public/albumSubmissionPage.html', {root: __dirname })
})

app.get('/dashboard_viewable',isSessionDead, (req, res) => {
  if(!req.session.userviewable)
  {
    res.redirect('/dashboard')
  }
  else {
    res.sendFile('./public/userviewable.html', {root: __dirname })
  }
})

app.get('/collection',isSessionDead, (req, res) => {
    res.sendFile('./public/user_collection.html', {root: __dirname })
})

app.get('/userviewable_collection',isSessionDead, (req, res) => {
    res.sendFile('./public/userviewable_collection.html', {root: __dirname })
})


app.get('/admin',isSessionDead, (req, res) => {
  if( req.session.user  == adminID) {
    res.sendFile('./public/admin-dashboard.html', {root: __dirname })
  } // admin profile
  else
  {
    res.redirect('/index')
  }
})

//USER INFO ROUTES

// A POST requests that adds a new user to the database
// the loginName is generated by the app
// This is calculated based on the num of users currently in the server
// profile pic, Password, displayname, bio are submitted by the user
app.post('/users', (req, res) => {
  const listenedToCollection = new Collection( {
    collectionName: "Listened to ",
    description: "Albums that you have listened to",
    albums:[]})

    const userCollection = []

    userCollection.push(listenedToCollection)

    const newUser = new User({
      loginName: req.body.loginName,
      password:  req.body.password,
      displayName: req.body.displayName,
      bio: req.body.bio,
      profilePic: req.body.photoURL,
      friendList: [],
      favAlbums: [],
      userReviews: [],
      userCollections: userCollection,
      userToListen: []
    })

    // // // Save the new user
    newUser.save().then((newUser) => {
      res.send(newUser)
    }, (error) => {
      res.send({"error": error})
    })
  })

  // A GET requests that returns the users within the datebase
  app.get('/users', (req, res) => {
    User.find().then((users) => {
      res.send({ users }) // can wrap in object if want to add more properties
    }, (error) => {
      res.status(500).send(error) // server error
    })
  })

  // A route to login and create a session
  app.post('/users/login', (req, res) => {
    const username = req.body.username
    const password = req.body.password

    // Use the static method on the User model to find a user
    // by their email and password
    User.findByUserPassword(username, password).then((user) => {
      if (!user) {
        res.redirect('/index');
      } else {
        // Add the user's id to the session cookie.
        // We can check later if this exists to ensure we are logged in.
        req.session.user = user._id;
        if( user._id == adminID)  // admin profile
        {
          res.redirect('/admin');
        }
        else
        {
          res.redirect('/dashboard');
        }
      }
    }).catch((error) => {
      res.status(400).redirect('/index');
    })
  })

  // A POST request that saves the id of the user we are about to view
  app.post('/viewUser',isSessionDead, (req, res) => {
    req.session.userviewable  = null
    if( req.body.userID != req.session.user  ) {
    req.session.userviewable =  req.body.userID
    }
    res.status(200).send()
  })

  // A GET requests that returns the session user
  app.get('/userinfo', (req, res) => {
    User.findById( req.session.user ).then((user) => {
      res.send({ user }) // can wrap in object if want to add more properties
    }, (error) => {
      res.status(500).send(error) // server error
    })
  })


  // A GET requests that returns the session user + the clicked collection
  app.get('/Collectioninfo', (req, res) => {
    User.findById( req.session.user ).then((user) => {
      const collection = user.userCollections[req.session.collectionid]
      res.send({ collection }) // can wrap in object if want to add more properties
    }, (error) => {
      res.status(500).send(error) // server error
    })
  })

  // A GET requests that returns the session user + the clicked collection
  app.get('/viewable_Collectioninfo', (req, res) => {
    User.findById( req.session.userviewable ).then((user) => {
      const collection = user.userCollections[req.session.collectionid]
      res.send({ collection }) // can wrap in object if want to add more properties
    }, (error) => {
      res.status(500).send(error) // server error
    })
  })

  // A POST request that saves the id of the user we are about to view
  app.post('/viewCollection',isSessionDead, (req, res) => {
    req.session.collectionid =  req.body.collectionIndex
    res.status(200).send( )
  })


  //ALBUM  INFO ROUTES

  // A GET requests that returns the albums within the datebase
  app.get('/albums', (req, res) => {
    Album.find().then((albums) => {
      res.send({ albums }) // can wrap in object if want to add more properties
    }, (error) => {
      res.status(500).send(error) // server error
    })
  })

  // A POST request that saves the id of the user we are about to view
  app.post('/viewAlbum',isSessionDead, (req, res) => {
    req.session.album =  req.body.albumID
    res.status(200).send()
  })

  // A GET requests that returns an album
  app.get('/albuminfo', (req, res) => {
    Album.findById( req.session.album ).then((album) => {
      res.send({ album }) // can wrap in object if want to add more properties
    }, (error) => {
      res.status(500).send(error) // server error
    })
  })

  // ALBUM REVIEW ROUTES
  app.get('/userViewable',  (req, res) => {
    User.findById( req.session.user ).then((user) => {
      const userView = new ViewableUser ( {
        _id:  user._id,
        displayName: user.displayName,
        profilePic: user.profilePic
      })
      res.send( userView ) // can wrap in object if want to add more properties
    }, (error) => {
      res.status(500).send(error) // server error
    })
  })

  app.post('/saveReviewUser', (req, res) => {
    User.findById( req.session.user ).then((user) => {

      const newAlbum = new savedAlbum ( {
        _id: req.body._id,
        name: req.body.name,
        cover: req.body.cover
      })

      const newReview = new Review ( {
        album: newAlbum,
        user: req.body.user ,
        dateOfReview:req.body.dateOfReview,
        reviewBody: req.body.reviewBody,
        rating: req.body.rating
      })

      user.userReviews.push(newReview)

      user.save().then((user) => {
        res.send( {user} )
      },(error) => {
        res.status(403).send(error) // server error
      })
    }, (error) => {
      res.status(500).send(error) // server error
    })
  })


  app.post('/saveReviewAlbum', (req, res) => {
    Album.findById( req.body._id ).then((album) => {

      const newAlbum = new savedAlbum ( {
        _id: req.body._id,
        name: req.body.name,
        cover: req.body.cover
      })

      const newReview = new Review ( {
        album: newAlbum,
        user: req.body.user ,
        dateOfReview:req.body.dateOfReview,
        reviewBody: req.body.reviewBody,
        rating: req.body.rating
      })

      let newAvr = 0
      album.Reviews.push(newReview)

      // getting the average rating
      for (let i = 0; i <album.Reviews.length; i++ )
      {
        newAvr = newAvr + album.Reviews[i].rating
      }

      newAvr = newAvr/ album.Reviews.length
      album.avgRating = newAvr
      album.save().then((album) => {
        res.send( {album} )
      },(error) => {
        res.status(403).send(error) // server error
      })
    }, (error) => {
      res.status(500).send(error) // server error
    })
  })

  // FAVOURITE ALBUM FUNCTIONALITY
  // A GET requests that users if the current users has favoured the album
  app.get('/albumFavourite', (req, res) => {
    User.findById( req.session.user ).then((user) => {
      const favAlbums = user.favAlbums
      res.send(favAlbums)
    }, (error) => {
      res.status(500).send(error) // server error
    })
  })


  // a POST request that adds a users to the current's users friendslist
  app.post('/favourAlbum', (req, res) => {
    const newfavourte = new savedAlbum( {
      _id:  req.body.albumID,
      name: req.body.name,
      cover: req.body.cover
    } )

    User.findById( req.session.user ).then((user) => {
      user.favAlbums.push(newfavourte)
      // Save the new user
      user.save().then((user) => {
        res.send( {user} )
      }, (error) => {
        res.send({"error": error})
      })
    },(error) => {
      res.status(400).send(error) // 400 for bad request
    })
  })

  // a patch request that removes a users to the current's users friendslist
  app.post('/unfavourAlbum', (req, res) => {
    const newFavouriteList = []

    User.findById( req.session.user ).then((user) => {
      for( let i =0; i < user.favAlbums.length; i++ )
      {
        if( user.favAlbums[i]._id != req.body.albumID)
        {
          newFavouriteList.push(user.favAlbums[i])
        }
      }
      user.favAlbums = newFavouriteList;

      // Save the new user
      user.save().then((user) => {
        res.send( {user} )
      }, (error) => {
        res.status(404).send({"error": error})
      })
    },(error) => {
      res.status(400).send(error) // 400 for bad request
    })
  })


  //LISTENED ALBUM FUNCTIONALITY
  // A GET requests that users if the current users has marked this album to listen to
  app.get('/albumListened', (req, res) => {
    User.findById( req.session.user ).then((user) => {
      const userListened = user.userCollections[0].albums
      res.send(userListened)
    }, (error) => {
      res.status(500).send(error) // server error
    })
  })


  // a POST request that adds an album to "To listen"
  app.post('/addListenedAlbum', (req, res) => {
    const newListen= new savedAlbum( {
      _id:  req.body.albumID,
      name: req.body.name,
      cover: req.body.cover
    } )

    User.findById( req.session.user ).then((user) => {
      user.userCollections[0].albums.push(newListen)
      user.save().then((user) => {
        res.send( {user} )
      }, (error) => {
        res.send({"error": error})
      })
    },(error) => {
      res.status(400).send(error) // 400 for bad request
    })
  })

  // a patch request that removes an album to the current's users to listen
  app.post('/removeFromListened', (req, res) => {
    const newToListened = []

    User.findById( req.session.user ).then((user) => {
      const userCollection = user.userCollections[0].albums
      for( let i =0; i < userCollection.length; i++ )
      {
        if( userCollection[i]._id != req.body.albumID)
        {
          newToListened.push(userCollection[i])
        }
      }
      user.userCollections[0].albums= newToListened;

      // Save the new user
      user.save().then((user) => {
        res.send( {user} )
      }, (error) => {
        res.status(404).send({"error": error})
      })
    },(error) => {
      res.status(400).send(error) // 400 for bad request
    })
  })


  //TO LISTEN ALBUM FUNCTIONALITY
  // A GET requests that users if the current users has marked this album to listen to
  app.get('/albumtoListen', (req, res) => {
    User.findById( req.session.user ).then((user) => {
      const userToListen = user.userToListen
      res.send(userToListen)
    }, (error) => {
      res.status(500).send(error) // server error
    })
  })

  // a POST request that adds an album to "To listen"
  app.post('/toListenAlbum', (req, res) => {
    const newListen= new savedAlbum( {
      _id:  req.body.albumID,
      name: req.body.name,
      cover: req.body.cover
    } )

    User.findById( req.session.user ).then((user) => {
      user.userToListen.push(newListen)
      user.save().then((user) => {
        res.send( {user} )
      }, (error) => {
        res.send({"error": error})
      })
    },(error) => {
      res.status(400).send(error) // 400 for bad request
    })
  })

  // a patch request that removes an album to the current's users to listen
  app.post('/removeToList', (req, res) => {
    const newToList = []

    User.findById( req.session.user ).then((user) => {
      for( let i =0; i < user.userToListen.length; i++ )
      {
        if( user.userToListen[i]._id != req.body.albumID)
        {
          newToList.push(user.userToListen[i])
        }
      }
      user.userToListen = newToList;

      // Save the new user
      user.save().then((user) => {
        res.send( {user} )
      }, (error) => {
        res.status(404).send({"error": error})
      })
    },(error) => {
      res.status(400).send(error) // 400 for bad request
    })
  })

  // VIEWING, FOLLOWING AND UNFOLLOWING ANOTHER USER
  // Rouets that handle the above tasks

  // A GET requests that returns the current user and the user they are viewing
  app.get('/userviewableinfo', (req, res) => {
    User.findById( req.session.userviewable ).then((user) => {
      res.send({ "currentUserid":req.session.user,  user })
    }, (error) => {
      res.status(500).send(error) // server error
    })
  })

  // A GET requests that users if the current users follows the user who
  // they are currently viewing
  app.get('/userFollowing', (req, res) => {
    User.findById( req.session.user ).then((user) => {
      const friendList = user.friendList
      res.send(friendList)
    }, (error) => {
      res.status(500).send(error) // server error
    })
  })


  // a POST request that adds a users to the current's users friendslist
  app.post('/followUser', (req, res) => {
    const newFriend = new ViewableUser( {
      _id:  req.body.userID,
      displayName: req.body.displayName,
      profilePic: req.body.profilePic
    } )

    User.findById( req.session.user ).then((user) => {
      user.friendList.push(newFriend)
      // Save the new user
      user.save().then((user) => {
        res.send( {user} )
      }, (error) => {
        res.send({"error": error})
      })
    },(error) => {
      res.status(400).send(error) // 400 for bad request
    })
  })

  // a patch request that removes a users to the current's users friendslist
  app.post('/unfollowUser', (req, res) => {
    const newFriendList = []

    User.findById( req.session.user ).then((user) => {
      for( let i =0; i < user.friendList.length; i++ )
      {
        if( user.friendList[i]._id != req.body.userID)
        {
          newFriendList.push(user.friendList[i])
        }
      }
      user.friendList = newFriendList;

      // Save the new user
      user.save().then((user) => {
        res.send( {user} )
      }, (error) => {
        res.status(404).send({"error": error})
      })
    },(error) => {
      res.status(400).send(error) // 400 for bad request
    })
  })

  //// IMAGE HANDLING
  // a POST route to *create* an image
  // returns the image
  app.post("/image", multipartMiddleware, (req, res) => {
    // Use uploader.upload API to upload image to cloudinary server.
    cloudinary.uploader.upload(  req.files.photo.path,  function (result) {
      res.send( result )
    })
  })

  /// ALBUMS SUBMISSIONS ROUTES
  // A POST request that approves a submitted album
  // id should be the id of a PendingAlbumSubmission
  app.post('/album/:id', (req, res) => {
    //Check session cookie to make sure current user is an admin
    if( req.session.user == adminID) {
      const albumId = req.params.id.slice(1);
      PendingAlbumSubmission.findById(albumId).then((submission) => {

        if (!submission) {
          res.status(404).send();
        } else {
          // create a new Album from the PendingAlbumSubmission
          const details = submission.details;
          const newAlbum = new Album({
            name: details.name,
            cover: details.cover,
            artist: details.artist,
            producer: details.producer,
            year: details.year,
            genre: details.genre,
            label: details.label,
            length: details.length,
            trackList: details.trackList,
            avgRating: details.avgRating,
            Reviews: details.Reviews
          });
          console.log(newAlbum);
          newAlbum.save().then((result) => {
            console.log("Approved album ", newAlbum.name);
            //Remove the pending submission
            PendingAlbumSubmission.deleteOne({_id: albumId}, (error) => {
              console.log(error);
            })
            res.send(result)
          }, (error) => {
            console.log(error);
            res.send({"error": error});
          });
        }
      }, (error) => {
        console.log(error);
        res.status(500).send(error);
      })
    } else {
      res.status(403).send();
    }
  })

  // posts an album submission to pendingAlbumSubmissions
  app.post('/pendingAlbumSubmissions', (req, res) => {
    if (! req.session.user )
    {
      res.status(400).send ({Error: "No user connected "})
      return
    }

    const newSubmission = new PendingAlbumSubmission({
      title: req.body.title,
      cover: req.body.cover,
      artists: req.body.artists,
      user: req.session.user,
      time: req.body.time,
      details: req.body.details
    })
    // Save the new pending album submission
    newSubmission.save().then((newSubmission) => {
      res.redirect('/dashboard')
    }, (error) => {
      console.log(error)
      res.send({"error": error})
    })
  })

  app.get('/pendingAlbumSubmissions',isSessionDead, (req, res) => {
    //Check session cookie to make sure current user is an admin
    if( req.session.user == adminID) {
      PendingAlbumSubmission.find().then((albums) => {
        const summaries = albums.map(function(album) {
          return {
            albumId: album._id,
            title: album.title,
            artists: album.artists,
            user: album.user,
            submissionDate: album.time
          }
        })
        res.send(summaries);
      }, (error) => {
        console.log(error);
        res.status(500).send();
      })
    } else { 
      res.status(403).send();
    }
  })

  // will use an 'environmental variable', process.env.PORT, for deployment.
  const port = process.env.PORT || 5000
  app.listen(port, () => {
    console.log(`Listening on port ${port}...`)
  })
