/* server.js - Express server for NoteWorthy*/
'use strict';

const adminID = '5e7e5bd54b8b10001761dcf4'

// Express
const express = require('express')
const app = express();
const bodyParser = require('body-parser')
app.use(bodyParser.json());

//CORS fix
const cors = require('cors');
app.use(cors());

// express-session for managing user sessions
const session = require('express-session')
app.use(bodyParser.urlencoded({ extended: true }));

// Mongo and Mongoose
const { ObjectID } = require('mongodb')
const { mongoose } = require('./db/mongoose');
const { Album } = require('./models/album')
const { User } = require('./models/user')
const { Review } = require('./models/review')
const { PendingAlbumSubmission } = require('./models/pendingAlbumSubmission')
const { Image } = require("./models/image");
const { Collection } = require("./models/collections");
const { ViewableUser } = require("./models/viewableuser");


// multipart middleware: allows you to access uploaded file from req.file
const multipart = require('connect-multiparty');
const multipartMiddleware = multipart();


// cloudinary: configure using credentials found on your Cloudinary Dashboard
const cloudinary = require('cloudinary');

cloudinary.config({
  cloud_name: 'keatingh',
  api_key: '583158277248312',
  api_secret: 'qEaGYgsVpsnQ2VY_9DbhYiSirv4'
});


app.use(express.static(__dirname + '/public'));

/*** Session handling **************************************/
// Create a session cookie
// Taken from lecture slides
app.use(session({
  secret: 'oursecret',
  resave: false,
  saveUninitialized: false,
  cookie: {
    httpOnly: true
  }
}));

// // Our own express middleware to check for
// // an active user on the session cookie (indicating a logged in user.)
//taken for the course notes
const sessionChecker = (req, res, next) => {
  if (req.session.user) {
    res.redirect('/dashboard'); // redirect to dashboard if logged in.
  } else {
    next(); // next() moves on to the route.
  }
};

// // Our own express middleware to check for
// // an active user on the session cookie (indicating a logged in user.)
//taken for the course notes
const isSessionDead = (req, res, next) => {
  if (!req.session.user) {
    res.redirect('/index'); // redirect to index if the session has died
  } else {
    next(); // next() moves on to the route.
  }
};

/// DIRECT TO WEB PAGES
app.get('/',(req, res) => {
  res.redirect('/index')
})

app.get('/index',sessionChecker,(req, res) => {
  res.sendFile('./public/index.html', {root: __dirname })
})

app.get('/newuser', (req, res) => {
  res.sendFile('/public/newuser.html', {root: __dirname })
})

app.get('/dashboard',isSessionDead, (req, res) => {
  res.sendFile('./public/dashboard.html', {root: __dirname })
})

app.get('/album',isSessionDead, (req, res) => {
  res.sendFile('./public/albumpage.html', {root: __dirname })
})

app.get('/submitalbum', isSessionDead,(req, res) => {
  res.sendFile('./public/albumSubmissionPage.html', {root: __dirname })
})


app.get('/dashboard_viewable',isSessionDead, (req, res) => {
  if(!req.session.userviewable)
  {
    res.redirect('/dashboard')
  }
  else {
    res.sendFile('./public/userviewable.html', {root: __dirname })
  }
})

app.get('/admin',isSessionDead, (req, res) => {
  if( req.session.user  == adminID) {
    res.sendFile('./public/admin-dashboard.html', {root: __dirname })
  } // admin profile
  else
  {
    res.redirect('/index')
  }
})

//USER INFO ROUTES

// A POST requests that adds a new user to the database
// the loginName is generated by the app
// This is calculated based on the num of users currently in the server
// profile pic, Password, displayname, bio are submitted by the user
  app.post('/users', (req, res) => {

  const listenedToCollection = new Collection( {
    collectionName: "Listened to ",
    description: "Albums that you have listened to",
    albums:[]})

    const userCollection = []

    userCollection.push(listenedToCollection)

    const newUser = new User({
      loginName: req.body.loginName,
      password:  req.body.password,
      displayName: req.body.displayName,
      bio: req.body.bio,
      profilePic: req.body.photoURL,
      friendList: [],
      favAlbums: [],
      userReviews: [],
      userCollections: userCollection,
      userToListen: []
    })

    // // // Save the new user
    newUser.save().then((newUser) => {
      res.send(newUser)
    }, (error) => {
      res.send({"error": error})
    })
  })

  // A GET requests that returns the users within the datebase
  app.get('/users', (req, res) => {
    User.find().then((users) => {
      res.send({ users }) // can wrap in object if want to add more properties
    }, (error) => {
      res.status(500).send(error) // server error
    })
  })

  // A route to login and create a session
  app.post('/users/login', (req, res) => {
    const username = req.body.username
    const password = req.body.password

    // Use the static method on the User model to find a user
    // by their email and password
    User.findByUserPassword(username, password).then((user) => {
      if (!user) {
        res.redirect('/index');
      } else {
        // Add the user's id to the session cookie.
        // We can check later if this exists to ensure we are logged in.
        req.session.user = user._id;
        if( user._id == adminID)  // admin profile
        {
          res.redirect('/admin');
        }
        else
        {
          res.redirect('/dashboard');
        }
      }
    }).catch((error) => {
      res.status(400).redirect('/index');
    })
  })

  // A POST request that saves the id of the user we are about to view
  app.post('/viewUser',isSessionDead, (req, res) => {
    req.session.userviewable =  req.body.userID
    res.status(200).send()
  })

  // A GET requests that returns the session user
  app.get('/userinfo', (req, res) => {
    User.findById( req.session.user ).then((user) => {
      res.send({ user }) // can wrap in object if want to add more properties
    }, (error) => {
      res.status(500).send(error) // server error
    })
  })

  //ALBUM  INFO ROUTES
  // A route to login and create a session
  app.post('/users/login', (req, res) => {
    const username = req.body.username
    const password = req.body.password

    // Use the static method on the User model to find a user
    // by their email and password
    User.findByUserPassword(username, password).then((user) => {
      if (!user) {
        res.redirect('/index');
      } else {
        // Add the user's id to the session cookie.
        // We can check later if this exists to ensure we are logged in.
        req.session.user = user._id;
        if( user._id == adminID)  // admin profile
        {
          res.redirect('/admin');
        }
        else
        {
          res.redirect('/dashboard');
        }
      }
    }).catch((error) => {
      res.status(400).redirect('/index');
    })
  })

  // A POST request that saves the id of the user we are about to view
  app.post('/viewAlbum',isSessionDead, (req, res) => {
    req.session.album =  req.body.albumID
    res.status(200).send()
  })

  // A GET requests that returns an album
  app.get('/albuminfo', (req, res) => {
    User.findById( req.session.album ).then((user) => {
      res.send({ user }) // can wrap in object if want to add more properties
    }, (error) => {
      res.status(500).send(error) // server error
    })
  })

  // VIEWING, FOLLOWING AND UNFOLLOWING ANOTHER USER
  // Rouets that handle the above tasks

  // A GET requests that returns the current user and the user they are viewing
  app.get('/userviewableinfo', (req, res) => {
    User.findById( req.session.userviewable ).then((user) => {
      res.send({ "currentUserid":req.session.user,  user })
    }, (error) => {
      res.status(500).send(error) // server error
    })
  })

  // A GET requests that users if the current users follows the user who
  // they are currently viewing
  app.get('/userFollowing', (req, res) => {
    User.findById( req.session.user ).then((user) => {
      const friendList = user.friendList
      res.send(friendList)
    }, (error) => {
      res.status(500).send(error) // server error
    })
  })

  // a POST request that adds a users to the current's users friendslist
  app.post('/followUser', (req, res) => {
    const newFriend = new ViewableUser( {
      _id:  req.body.userID,
      displayName: req.body.displayName,
      profilePic: req.body.profilePic
    } )

    User.findById( req.session.user ).then((user) => {
      user.friendList.push(newFriend)
      // Save the new user
      user.save().then((user) => {
        res.send( {user} )
      }, (error) => {
        res.send({"error": error})
      })
    },(error) => {
      res.status(400).send(error) // 400 for bad request
    })
  })

  // a patch request that removes a users to the current's users friendslist
  app.post('/unfollowUser', (req, res) => {
    const newFriendList = []

    User.findById( req.session.user ).then((user) => {
      for( let i =0; i < user.friendList.length; i++ )
      {
        if( user.friendList[i]._id != req.body.userID)
        {
          newFriendList.push(user.friendList[i])
        }
      }
      user.friendList = newFriendList;

      // Save the new user
      user.save().then((user) => {
        res.send( {user} )
      }, (error) => {
        res.status(404).send({"error": error})
      })
    },(error) => {
      res.status(400).send(error) // 400 for bad request
    })
  })

  //// IMAGE HANDLING
  // a POST route to *create* an image
  // returns the image
  app.post("/image", multipartMiddleware, (req, res) => {
    // Use uploader.upload API to upload image to cloudinary server.
    cloudinary.uploader.upload(  req.files.photo.path,  function (result) {
      res.send( result )
    })
  })

  /// ALBUMS SUBMISSIONS ROUTES
  // A POST request that approves a submitted album
  // id should be the id of a PendingAlbumSubmission
  app.post('/album/:id', (req, res) => {
    const albumId = req.params.id.slice(1);
    PendingAlbumSubmission.findById(albumId).then((submission) => {

      if (!submission) {
        res.status(404).send();
      } else {
        // create a new Album from the PendingAlbumSubmission
        const details = submission.details;
        const newAlbum = new Album({
          name: details.name,
          cover: details.cover,
          artist: details.artist,
          producer: details.producer,
          year: details.year,
          genre: details.genre,
          label: details.label,
          length: details.length,
          trackList: details.trackList,
          avgRating: details.avgRating,
          Reviews: details.Reviews
        });
        console.log(newAlbum);
        newAlbum.save().then((result) => {
          console.log("Approved album ", newAlbum.name);
          //Remove the pending submission
          PendingAlbumSubmission.deleteOne({_id: albumId}, (error) => {
            console.log(error);
          })
          res.send(result)
        }, (error) => {
          console.log(error);
          res.send({"error": error});
        });
      }
    }, (error) => {
      console.log(error);
      res.status(500).send(error);
    })
  })

  // posts an album submission to pendingAlbumSubmissions
  app.post('/pendingAlbumSubmissions', (req, res) => {
    if (! req.session.user )
    {
      res.status(400).send ({Error: "No user connected "})
      return
    }

    const newSubmission = new PendingAlbumSubmission({
      title: req.body.title,
      cover: req.body.cover,
      artists: req.body.artists,
      user: req.session.user,
      time: req.body.time,
      details: req.body.details
    })
    // Save the new pending album submission
    newSubmission.save().then((newSubmission) => {
      res.redirect('/dashboard')
    }, (error) => {
      console.log(error)
      res.send({"error": error})
    })
  })

  app.get('/pendingAlbumSubmissions', (req, res) => {
    //TODO: Check session cookie to make sure current user is an admin
    PendingAlbumSubmission.find().then((albums) => {
      const summaries = albums.map(function(album) {
        return {
          albumId: album._id,
          title: album.title,
          artists: album.artists,
          user: album.user,
          submissionDate: album.time
        }
      })
      res.send(summaries);
    }, (error) => {
      console.log(error);
      res.status(500).send();
    })
  })

  // will use an 'environmental variable', process.env.PORT, for deployment.
  const port = process.env.PORT || 5000
  app.listen(port, () => {
    console.log(`Listening on port ${port}...`)
  })
